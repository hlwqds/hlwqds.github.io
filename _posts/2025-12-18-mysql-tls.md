---
layout: post
title: MySQL SSL 开发环境配置与排查深度复盘
date: 2025-12-17 10:00:00 +0800
categories: [mysql]
tags: [mysql, tls]
---

# MySQL SSL 开发环境配置与排查深度复盘

本文档详细记录了在 Docker 环境下配置 MySQL 8.0 SSL 开发环境的全过程。按排查逻辑顺序组织，还原从报错到解决的完整上下文。

---

## 第一阶段：起因与初次报错

### 1. 目标
我们需要在开发环境（Docker）中运行 MySQL，并将端口 `3306` 映射到宿主机的 `33306`，以便本地工具（如 Gobang, DBeaver）连接。

### 2. 遇到的问题：`InvalidDNSNameError`
当我们尝试通过 `172.16.58.128:33306` 连接时，Gobang 报错：
> `error occurred while attempting to establish a TLS connection: InvalidDNSNameError`

### 3. 原因分析
*   MySQL 默认启用 SSL，并使用自签名证书。
*   默认证书的 `Common Name (CN)` 通常是 `MySQL_Server_...` 或 `localhost`。
*   客户端尝试连接 IP `172.16.58.128`，但证书里没有这个 IP。
*   **客户端的安全机制（Rustls/OpenSSL）发现证书持有者名称与目标 IP 不一致，拒绝连接。**

---

## 第二阶段：尝试修复 —— 生成自签名证书

为了解决上述错误，我们决定生成一张**包含 IP 地址**的证书。

### 1. 操作步骤
我们创建了 `san.cnf` 配置文件，指定了 `Subject Alternative Name (SAN)`：
```ini
# controller/certs/san.cnf
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
CN = MySQL Dev Server
O = Sentinel Flow
OU = Dev

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
IP.1 = 172.16.58.128
DNS.1 = localhost
```

然后使用 OpenSSL 命令生成证书链（脚本路径：`gen_certs.sh`）：

```bash
# 1. 生成 CA (根证书)
openssl genrsa 2048 > ca-key.pem
openssl req -new -x509 -nodes -days 3650 -key ca-key.pem -out ca.pem -subj "/CN=Sentinel Dev CA"

# 2. 生成服务器私钥和请求 (CSR)
openssl req -newkey rsa:2048 -nodes -keyout server-key.pem -out server-req.pem -config san.cnf

# 3. 使用 CA 签署服务器证书 (带 SAN 扩展)
# 这一步至关重要，必须把 san.cnf 作为 extfile 传入，否则 IP 信息不会被写入证书
openssl x509 -req -in server-req.pem -days 3650 -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out server-cert.pem -extensions v3_req -extfile san.cnf

# 4. 生成客户端证书 (用于双向认证)
openssl req -newkey rsa:2048 -nodes -keyout client-key.pem -out client-req.pem -subj "/CN=Sentinel Dev Client"
openssl x509 -req -in client-req.pem -days 3650 -CA ca.pem -CAkey ca-key.pem -set_serial 02 -out client-cert.pem
```

这样我们就得到了包含 `IP:172.16.58.128` 的 `server-cert.pem`，可以被客户端正确验证。

### 2. 新的问题：`Unable to get private key`
将证书挂载到 Docker 后，MySQL 容器启动失败：
> `[Server] SSL error: Unable to get private key from '/etc/mysql/certs/server-key.pem'`

*   **原因**: 宿主机上生成的私钥文件权限默认是 `600` (仅 root 可读)。映射进容器后，容器内的 `mysql` 用户（uid 999）无法读取。
*   **解决**: 在宿主机执行 `chmod 644 server-key.pem`。

---

## 第三阶段：深入原理 —— 证书交换与 TLS 协议

在配置好证书后，我们深入探讨了 SSL 握手的细节。

### 1. 为什么抓包看不到证书 (`server-cert.pem`)？
我们尝试用 Wireshark 抓包，却发现找不到证书的明文传输。
*   **现象**: 看到 `Server Hello` 后，紧接着全是 `Encrypted Handshake Message`。
*   **原因**: 双方协商使用了 **TLS 1.3** 协议。
    *   **TLS 1.2**: 证书在握手阶段明文发送。
    *   **TLS 1.3**: 在 `Server Hello` 之后立即切换到加密模式，**证书本身也是被加密传输的**。
*   **结论**: 看不到是正常的，说明 TLS 1.3 安全机制生效了。

### 2. CA 签名的必要性
*   **问题**: 既然公钥能加密，为什么一定要 CA 签名？
*   **解答**: 防止**中间人攻击 (Man-in-the-Middle)**。
    *   黑客可以给客户端发自己的公钥。如果没有 CA 证书（公章）做验证，客户端无法区分这个公钥是属于服务器的还是黑客的。
    *   **CA 证书 (`ca.pem`)** 充当了“公安局”的角色，用来验证服务端出示的“身份证”是否伪造。

---

## 第四阶段：连接断开与客户端兼容性

### 1. 现象：Greeting 后连接断开
在解决了证书和权限后，Gobang 客户端连接时表现为：收到服务端的 Greeting 包后立即断开连接。

### 2. 原因推测
*   **兼容性**: Gobang（或其底层驱动）可能在处理 MySQL 8.0 的 SSL 握手或特定的 Greeting 包格式时存在 bug。
*   **强制策略冲突**: 客户端配置可能与服务端实际协商的参数（如 TLS 版本）不匹配。

### 3. 验证方法
使用官方 `mysql` 客户端连接成功，证明服务端配置无误。
```bash
mysql -h 172.16.58.128 -P 33306 -u root -p --ssl-ca=~/.config/gobang/certs/ca.pem --ssl-mode=VERIFY_IDENTITY
```
这确认了问题出在 Gobang 客户端对特定环境的支持上。

---

## 第五阶段：双向认证 (mTLS) 模拟

最后，我们模拟了最高安全级别的**双向认证**。

### 1. 配置逻辑
*   **服务端**: 不仅出示自己的证书，还要求客户端出示证书 (`REQUIRE X509`)。
*   **客户端**: 连接时必须提供 `client-cert.pem` 和 `client-key.pem`。

### 2. 关键误区：密码还需要吗？
*   **误区**: 以为有了证书就不用输密码了。
*   **现实**: `REQUIRE X509` 是在密码验证之上的**叠加条件**。
    *   连接流程：TCP -> TLS 握手（互换证书验证） -> 成功建立加密通道 -> MySQL 协议登录（发送用户名/密码）。
*   **免密方案**: 若要实现仅凭证书登录，需将数据库用户密码设为空，并配合 `REQUIRE SUBJECT` 锁定特定证书。

```bash
mysql -h 172.16.58.128 -P 33306 -u client_mtls -p --ssl-ca=~/.config/gobang/certs/ca.pem --ssl-cert=~/.config/gobang/certs/client-cert.pem --ssl-key=~/.config/gobang/certs/client-key.pem --ssl-mode=VERIFY_CA
```

---

## 总结：最佳实践建议

1.  **本地快速开发**: 推荐在 Docker Command 中使用 `--skip-ssl`，避免各种客户端的 SSL 兼容性烦恼。
2.  **生产环境/远程调试**: 必须生成带 SAN (IP/域名) 的证书，并强制客户端使用 `VERIFY_CA` 或 `VERIFY_IDENTITY` 模式，确保连接不被劫持。
---

## 附录：完整的 Docker Compose 配置

这是我们最终调试成功的 `controller/docker-compose-dev.yaml` 文件内容

```yaml
version: '3'
services:
  mysql:
    image: mysql:8.0
    container_name: sentinel_controller_db_dev
    command:
      - --skip-name-resolve
      - --ssl-ca=/etc/mysql/certs/ca.pem
      - --ssl-cert=/etc/mysql/certs/server-cert.pem
      - --ssl-key=/etc/mysql/certs/server-key.pem
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: sentinel_flow_controller_dev
    ports:
      - "33306:3306"
    volumes:
      - ./certs:/etc/mysql/certs
```
